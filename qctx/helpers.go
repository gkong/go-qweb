// Copyright 2016 George S. Kong. All rights reserved.
// Use of this source code is governed by a license that can be found in the LICENSE.txt file.

package qctx

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
)

// ReadJSON unmarshals JSON from the request body into the object referenced by dest,
// which must have a deserializer, which can be hand-written or generated by
// ffjson or a similar tool. If it fails, it calls http.Error() and returns false.
func (c *Ctx) ReadJSON(dest json.Unmarshaler) bool {
	reqBody, err := ioutil.ReadAll(c.R.Body)
	if err != nil {
		c.Error("error reading JSON request", http.StatusBadRequest)
		return false
	}
	if err := dest.UnmarshalJSON(reqBody); err != nil {
		c.Error("error parsing JSON request", http.StatusBadRequest)
		return false
	}
	return true
}

// WriteJSON marshals JSON from the object referenced by src into the request body.
// src must have a deserializer, which can be hand-written or generated by
// ffjson or a similar tool. If it fails, it calls http.Error().
func (c *Ctx) WriteJSON(src json.Marshaler) {
	data, err := src.MarshalJSON()
	if err != nil {
		c.Error("error creating JSON response", http.StatusInternalServerError)
	}
	c.W.Header().Set("Content-Type", "application/json")
	if nbytes, err := c.W.Write(data); err != nil || nbytes != len(data) {
		c.Error("error writing JSON to response", http.StatusInternalServerError)
	}
}

// Error is a simple wrapper for http.Error.
func (c *Ctx) Error(s string, code int) {
	http.Error(c.W, s, code)
}
