// Copyright 2016 George S. Kong. All rights reserved.
// Use of this source code is governed by a license that can be found in the LICENSE.txt file.

// Password store - currently only supports goleveldb and cassandra.

package main

import (
	"encoding/binary"
	"errors"

	"github.com/gocql/gocql"
	"golang.org/x/crypto/bcrypt"
)

// pwAuth authenticates, using the currently-selected, database-specific authenticator.
var pwAuth authenticator

type authenticator interface {
	auth(user string, password string) (userID []byte, err error)
}

type authFunc func(user string, password string) (userID []byte, err error)

func (f authFunc) auth(user string, password string) (userID []byte, err error) {
	return f(user, password)
}

// pwAdd adds an entry to the currently-selected password store.
// it exists solely to allow the load test to insert entries into
// the password store. it accepts an integer "userid" parameter,
// which would not be generated by, nor visible to, users in a production app.
var pwAdd addpw

type addpw interface {
	add(user string, password string, userid int) error
}

type addPwFunc func(user string, password string, userid int) error

func (f addPwFunc) add(user string, password string, userid int) error {
	return f(user, password, userid)
}

func pwSetup(dbt dbTypeEnum) {
	dbSetup(dbt)

	switch dbt {
	case goleveldbDB:
		gldbPwStore()
		pwAdd = addPwFunc(gldbAddPw)
		pwAuth = authFunc(gldbAuth)
	case cassandraDB:
		cassPwStore()
		pwAdd = addPwFunc(cassAddPw)
		pwAuth = authFunc(cassAuth)
	case mysqlDB:
		panic("no mysql password store")
	case mapDB:
		panic("no map password store")
	}

	// add a user, for testing. this operation is idempotent
	pwAdd.add("me", "abc", 0)
}

//
// goleveldb password store
//

const bytesPerUint64 = 8

var gldbPassPrefix []byte

func gldbPwStore() {
	gldbPassPrefix = istobs(Config.Goleveldb.PasswdKeyPrefix)
}

func gldbAddPw(user string, password string, userid int) error {
	hashedPass, err := bcrypt.GenerateFromPassword([]byte(password), Config.BcryptCost)
	if err != nil {
		return errors.New("gldbAddPw - bcrypt failed")
	}
	val := gldbPassValue(make([]byte, bytesPerUint64+len(hashedPass)))
	itob(val, int64(userid))
	copy(val[bytesPerUint64:], hashedPass)
	return gldb.Put(gldbPassKey(user), val, nil)
}

func gldbAuth(user string, password string) ([]byte, error) {
	data, err := gldb.Get(gldbPassKey(user), nil)
	if err != nil {
		return []byte{}, errors.New("gldbAuth - user not in database")
	}

	dbValue := gldbPassValue(data)
	if bcrypt.CompareHashAndPassword(dbValue.password(), []byte(password)) != nil {
		return []byte{}, errors.New("gldbAuth - password mismatch")
	}

	return dbValue.userid(), nil
}

// goleveldb password table schema helpers
//
//   key: prefix | username
//
//   value: userid | hashed password

func gldbPassKey(user string) []byte {
	key := make([]byte, len(user)+len(gldbPassPrefix))
	copy(key, gldbPassPrefix)
	copy(key[len(gldbPassPrefix):], user)
	return key
}

type gldbPassValue []byte

func (v *gldbPassValue) userid() []byte {
	return (*v)[:bytesPerUint64]
}

func (v *gldbPassValue) password() []byte {
	return (*v)[bytesPerUint64:]
}

//
// cassandra password store
//

func cassPwStore() {
	cdb.Query(`CREATE TABLE IF NOT EXISTS ` + Config.Cassandra.PasswordTableName +
		` (username varchar, password varchar, userid UUID, PRIMARY KEY(username));`).Exec()
}

func cassAddPw(user string, password string, userid int) error {
	var uu gocql.UUID
	q := `SELECT userid FROM ` + Config.Cassandra.PasswordTableName + ` WHERE username = '` + user + `' LIMIT 1`
	if err := cdb.Query(q).Scan(&uu); err != nil {
		// make a degenerate "UUID" that is just userid padded with zeroes
		uub := uu.Bytes()
		ii := userid
		for j := len(uub) - 1; j >= 0; j-- {
			uub[j] = byte(ii % 255)
			ii /= 256
		}
		uu, _ = gocql.UUIDFromBytes(uub)
		hashedPass, err := bcrypt.GenerateFromPassword([]byte(password), Config.BcryptCost)
		if err != nil {
			return errors.New("cassAddPw - bcrypt failed")
		}
		table := Config.Cassandra.KeySpace + "." + Config.Cassandra.PasswordTableName
		q = `INSERT INTO ` + table + ` (username, password, userid) VALUES (?, ?, ?);`
		return cdb.Query(q, user, string(hashedPass), uu).Exec()
	}
	return nil
}

func cassAuth(user string, password string) ([]byte, error) {
	var hashedPass string
	var userID gocql.UUID

	q := `SELECT password, userid FROM ` + Config.Cassandra.PasswordTableName + ` WHERE username = ? LIMIT 1`
	if err := cdb.Query(q, user).Consistency(gocql.One).Scan(&hashedPass, &userID); err != nil {
		return []byte{}, errors.New("cassandraAuth - user not in database")
	}

	if bcrypt.CompareHashAndPassword([]byte(hashedPass), []byte(password)) != nil {
		return []byte{}, errors.New("cassandraAuth - password mismatch")
	}

	return userID.Bytes(), nil
}

// convert int64 to []byte
func itob(dest []byte, i int64) {
	binary.LittleEndian.PutUint64(dest, uint64(i))
}
